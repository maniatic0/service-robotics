{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"LEf",
				"LeftWeird"
			],
			[
				"LEFT",
				"LEFT_WEIRD"
			],
			[
				"Right",
				"RightCorner"
			],
			[
				"Lef",
				"LeftCorner"
			],
			[
				"whi",
				"white_corner"
			],
			[
				"LEF",
				"LEFT_CORNER"
			],
			[
				"LE",
				"LEFT_LINE_SENSOR"
			],
			[
				"RIGHT",
				"RIGHT_CORNER"
			],
			[
				"en",
				"entering_intersection"
			],
			[
				"On",
				"OnIntersection"
			],
			[
				"RIGHT_T",
				"RIGHT_RIGHT_LINE_SENSOR"
			],
			[
				"mo",
				"MOTORS"
			],
			[
				"fo",
				"FORWARD"
			],
			[
				"pri",
				"println"
			],
			[
				"SP",
				"LEFT_SPEAKER"
			],
			[
				"SPE",
				"SPEAKER_THRESHOLD"
			],
			[
				"sw",
				"switch\tArduino switch"
			],
			[
				"LINE",
				"LINE_SENSORS"
			],
			[
				"tar",
				"target_pos"
			],
			[
				"fina",
				"final_map"
			],
			[
				"if",
				"if\tIf Condition"
			],
			[
				"sta",
				"start_pos"
			],
			[
				"int",
				"interpolate"
			],
			[
				"in",
				"infinity_post"
			],
			[
				"pr",
				"print"
			],
			[
				"set",
				"setConstants"
			],
			[
				"No",
				"no"
			],
			[
				"read",
				"reader"
			],
			[
				"con",
				"constants"
			],
			[
				"In",
				"InterpretedInstruction"
			],
			[
				"vec",
				"vector"
			],
			[
				"ge",
				"generateJointPathTrajectory"
			],
			[
				"ins",
				"instruction"
			],
			[
				"st",
				"START_POSITION"
			],
			[
				"star",
				"START_VELOCITY"
			],
			[
				"fi",
				"fileReader"
			],
			[
				"deg2rad",
				"DEG2RAD"
			],
			[
				"Ve",
				"Vector3"
			],
			[
				"re",
				"reader"
			],
			[
				"cur",
				"current_pos"
			],
			[
				"sq",
				"sqrt"
			],
			[
				"de",
				"decimal"
			],
			[
				"f",
				"fromValuesToLine"
			],
			[
				"__",
				"__repr__"
			],
			[
				"def",
				"def\tFunction"
			],
			[
				"norm",
				"normalized"
			],
			[
				"nor",
				"normalize"
			],
			[
				"no",
				"normalize"
			],
			[
				"try",
				"try\tTry/Except"
			],
			[
				"vecto",
				"Vector3"
			],
			[
				"N",
				"N"
			],
			[
				"us",
				"username"
			],
			[
				"Nu",
				"NUMERIC"
			],
			[
				"RE",
				"REFERENCES"
			],
			[
				"las",
				"lastname"
			],
			[
				"b",
				"balance"
			]
		]
	},
	"buffers":
	[
		{
			"file": "solver.py",
			"settings":
			{
				"buffer_size": 5161,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"contents": "#include <Servo.h>\n\n#define LEFT_FORWARD 0 \n#define STOP 90 \n#define LEFT_BACKWARD 180 \n#define RIGHT_FORWARD 180 \n#define RIGHT_BACKWARD 0 \n#define MOTORS 2\n#define LEFT_MOTOR 0\n#define RIGHT_MOTOR 1\n\n\nServo left_servo;  // create servo object to control a servo\nServo right_servo;  // create servo object to control a servo\nint servoPin[] = {9, 10};\nfloat motor_signal[MOTORS] = {0,0};\n\n// twelve servo objects can be created on most boards\n\nint outSignal = 90;    // variable to store the servo position\nint inSignal = 90;\nfloat test;\nint readPin = 0;\n\n\n#define LINE_THRESHOLD 400\n#define ANALOG_MAX 1023\n#define LINE_SENSORS 4\n#define LEFT_LEFT_LINE_SENSOR 0\n#define LEFT_LINE_SENSOR 1\n#define RIGHT_LINE_SENSOR 2\n#define RIGHT_RIGHT_LINE_SENSOR 3\n#define LINE_STOPING_CONSTANT 8/9\n\nint line_read_pin[LINE_SENSORS] = {0, 1, 2, 3};\nfloat line_reading[LINE_SENSORS] = {0, 0, 0, 0};\nfloat line_signal[MOTORS] = {0, 0};\n\n\nint trigPin[] = {1,3,5};\nint echoPin[] = {2,4,6};\nlong distance[] = {0,0,0};\n#define MAGIC_SPEAKER_CONSTANT 29.1\n#define SPEAKER_AMOUNT 3\n#define LEFT_SPEAKER 0\n#define FRONT_SPEAKER 1\n#define RIGHT_SPEAKER 2\n#define SPEAKER_THRESHOLD 30\n\n#define BUTTON_PIN 7\n\nbool button_state = false;\n\n#define FORWARD 0\n#define LEFT_CORNER 1\n#define RIGHT_CORNER 2\n#define LEFT_CROSS 3\n#define RIGHT_CROSS 4\n#define LEFT_T 5\n#define RIGHT_T 6\n#define LEFT_WEIRD 7\n#define RIGHT_WEIRD 8\n#define TARGET 9\n#define ENTRANCE 10\nint dir = 0;\n\nbool on_intersection = false;\nbool entering_intersection = false;\nbool exiting_intersection = false;\nbool top_corner = false; // If we are on top of a top_corner afer hitting the right right sensor\nbool white_corner = false; // for cross intersections\nbool black_corner = false; // for cross intersections\nbool second_white_corner = false; // for cross intersections\n\n\n\nfloat ReadLineSensor(int i){\n    return float(analogRead(line_read_pin[i]) - LINE_THRESHOLD) / float(ANALOG_MAX);\n}\n\nvoid ReadLineSensors() {\n    for(int i=0; i<LINE_SENSORS; i++){\n        line_reading[i] = ReadLineSensor(i);\n    }\n}\n\nbool OnLine(int i) {\n    return line_reading[i] >= 0;\n}\n\nbool OnIntersection(){\n    return OnLine(LEFT_LEFT_LINE_SENSOR) || OnLine(RIGHT_RIGHT_LINE_SENSOR);\n}\n\n\nvoid NormalLineControl() {\n    if (OnLine(LEFT_LINE_SENSOR))\n    {\n        line_signal[LEFT_MOTOR] = STOP * LINE_STOPING_CONSTANT;\n    }\n    else\n    {\n        line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n    }\n\n    if (OnLine(RIGHT_LINE_SENSOR))\n    {\n        line_signal[RIGHT_MOTOR] = STOP  * (2 - LINE_STOPING_CONSTANT) ;\n    }\n    else\n    {\n        line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n    }\n}\n\nvoid Forward(){\n    line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n    line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n\n    //After an intersection mark as a normal path again\n    if (!on_intersection && entering_intersection && !exiting_intersection)\n    {\n        exiting_intersection = true;\n        entering_intersection = false;\n    }\n}\n\nvoid LeftCorner(){\n    if (!top_corner)\n    {\n        line_signal[LEFT_MOTOR] = STOP;\n        line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n    }\n    else\n    {\n        line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n        line_signal[RIGHT_MOTOR] = STOP;\n    }\n    \n    //After an intersection mark as a normal path again\n    if (OnLine(RIGHT_RIGHT_LINE_SENSOR) && !top_corner)\n    {\n        top_corner = true;\n    }\n\n    if (OnLine(LEFT_LINE_SENSOR) && top_corner && entering_intersection && !exiting_intersection)\n    {\n        exiting_intersection = true;\n        entering_intersection = false;\n        top_corner = false;\n    }\n}\n\nvoid RightCorner(){\n    if (!top_corner)\n    {\n        line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n        line_signal[RIGHT_MOTOR] = STOP;\n    }\n    else\n    {\n        line_signal[LEFT_MOTOR] = STOP;\n        line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n    }\n    \n    //After an intersection mark as a normal path again\n    if (OnLine(LEFT_LEFT_LINE_SENSOR) && !top_corner)\n    {\n        top_corner = true;\n    }\n\n    if (OnLine(RIGHT_LINE_SENSOR) && top_corner && entering_intersection && !exiting_intersection)\n    {\n        exiting_intersection = true;\n        entering_intersection = false;\n        top_corner = false;\n    }\n}\n\n\nvoid LeftCross(){\n    // We haven't reached half of the turn\n    if (!(white_corner && black_corner && second_white_corner))\n    {\n        line_signal[LEFT_MOTOR] = STOP;\n        line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n    }\n    else\n    {\n        LeftCorner();\n    }\n    \n    if (!OnLine(RIGHT_RIGHT_LINE_SENSOR))\n    {\n        if (!white_corner)\n        {\n            white_corner = true;\n        }\n        else if(!second_white_corner && black_corner) {\n            second_white_corner = true;\n        }\n    }\n    else {\n        if (!black_corner && white_corner)\n        {\n            black_corner = true;\n        }\n    }\n}\n\nvoid RightCross(){\n    // We haven't reached half of the turn\n    if (!(white_corner && black_corner && second_white_corner))\n    {\n        line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n        line_signal[RIGHT_MOTOR] = STOP;\n    }\n    else\n    {\n        RightCorner();\n    }\n    \n    if (!OnLine(LEFT_LEFT_LINE_SENSOR))\n    {\n        if (!white_corner)\n        {\n            white_corner = true;\n        }\n        else if(!second_white_corner && black_corner) {\n            second_white_corner = true;\n        }\n    }\n    else {\n        if (!black_corner && white_corner)\n        {\n            black_corner = true;\n        }\n    }\n}\n\n\nvoid LeftT(){\n    // We haven't reached half of the turn\n    if (!white_corner)\n    {\n        line_signal[LEFT_MOTOR] = STOP;\n        line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n    }\n    else\n    {\n        LeftCorner();\n    }\n    \n    if (!OnLine(RIGHT_RIGHT_LINE_SENSOR))\n    {\n        if (!white_corner)\n        {\n            white_corner = true;\n        }\n    }\n}\n\nvoid RightT(){\n    // We haven't reached half of the turn\n    if (!white_corner)\n    {\n        line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n        line_signal[RIGHT_MOTOR] = STOP;\n    }\n    else\n    {\n        RightCorner();\n    }\n    \n    if (!OnLine(LEFT_LEFT_LINE_SENSOR))\n    {\n        if (!white_corner)\n        {\n            white_corner = true;\n        }\n    }\n}\n\nvoid LeftWeird(){\n    // We haven't reached half of the turn\n    if (!(white_corner && black_corner))\n    {\n        line_signal[LEFT_MOTOR] = STOP;\n        line_signal[RIGHT_MOTOR] = RIGHT_FORWARD;\n    }\n    else\n    {\n        LeftCorner();\n    }\n    \n    if (!OnLine(RIGHT_RIGHT_LINE_SENSOR))\n    {\n        if (!white_corner && black_corner)\n        {\n            white_corner = true;\n        }\n    }\n    else{\n        if (!black_corner)\n        {\n            black_corner = true;\n        }\n    }\n}\n\nvoid RightWeird(){\n    // We haven't reached half of the turn\n    if (!(white_corner && black_corner))\n    {\n        line_signal[LEFT_MOTOR] = LEFT_FORWARD;\n        line_signal[RIGHT_MOTOR] = STOP;\n    }\n    else\n    {\n        RightCorner();\n    }\n    \n    if (!OnLine(LEFT_LEFT_LINE_SENSOR))\n    {\n        if (!white_corner && black_corner)\n        {\n            white_corner = true;\n        }\n    }\n    else {\n        if (!black_corner)\n        {\n            black_corner = true;\n        }\n    }\n}\n\nvoid LineControl() {\n    on_intersection = OnIntersection();\n    //End of the intersection\n    if (!on_intersection && !(entering_intersection && !exiting_intersection))\n    {\n        NormalLineControl();\n        return;\n    }\n\n    //If we do not want to make the NormalLineControl and we are still on the Intersection. Just mark the entrance on the Intersection\n    if (!entering_intersection)\n    {\n        entering_intersection = true;\n        exiting_intersection = false;\n        top_corner = false;\n        white_corner = false;\n        black_corner = false;\n        second_white_corner = false;\n    }\n\n\n    switch (dir) {\n        case FORWARD:\n          Forward();\n          break;\n        case LEFT_CORNER:\n          LeftCorner();\n          break;\n        case RIGHT_CORNER:\n          RightCorner();\n          break;\n        case LEFT_CROSS:\n          LeftCross();\n          break;\n        case RIGHT_CROSS:\n          RightCross();\n          break;\n        case LEFT_T:\n          LeftT();\n          break;\n        case RIGHT_T:\n          RightT();\n          break;\n        case LEFT_WEIRD:\n          LeftWeird();\n          break;\n        case RIGHT_WEIRD:\n          RightWeird();\n          break;\n        default:\n          break;\n    }\n}\n\n\nvoid ReadSpeakers(){\n    for(int i=0; i<SPEAKER_AMOUNT; i++){\n        digitalWrite(trigPin[i], LOW);  // Added this line\n        delayMicroseconds(2); // Added this line\n        digitalWrite(trigPin[i], HIGH);\n        delayMicroseconds(10); // Added this line\n        digitalWrite(trigPin[i], LOW);\n        distance[i] = (pulseIn(echoPin[i], HIGH)/2) / MAGIC_SPEAKER_CONSTANT;\n    }\n}\n\nbool OutOfRange(int i) {\n    return distance[i] >= SPEAKER_THRESHOLD || distance[i] <= 0;\n}\n\n\nvoid MotorControl(){\n    ReadLineSensors();\n    LineControl();\n    ReadSpeakers();\n\n\n    motor_signal[LEFT_MOTOR] = line_signal[LEFT_MOTOR];\n    motor_signal[RIGHT_MOTOR] = line_signal[RIGHT_MOTOR];\n\n    if (OutOfRange(LEFT_SPEAKER) && OutOfRange(RIGHT_SPEAKER))\n    {\n        motor_signal[LEFT_MOTOR] = STOP;\n        motor_signal[RIGHT_MOTOR] = STOP;\n    }\n    else if (!OutOfRange(FRONT_SPEAKER)) \n    {\n        motor_signal[LEFT_MOTOR] = STOP;\n        motor_signal[RIGHT_MOTOR] = STOP;\n    }\n\n\n    left_servo.write(motor_signal[LEFT_MOTOR]);\n    right_servo.write(motor_signal[RIGHT_MOTOR]);\n}\n\nvoid Button(){\n    if (digitalRead(BUTTON_PIN) == HIGH)\n    {\n        button_state = !button_state;\n    }\n}\n\nvoid setup() {\n    left_servo.attach(servoPin[LEFT_MOTOR]);\n    right_servo.attach(servoPin[RIGHT_MOTOR]);\n    left_servo.write(STOP);\n    right_servo.write(STOP);\n\n    for(int i=0; i<LINE_SENSORS; i++){\n        pinMode(line_read_pin[i],INPUT);\n    }\n\n    for(int i=0; i<SPEAKER_AMOUNT; i++){\n        pinMode(trigPin[i], OUTPUT);\n        pinMode(echoPin[i], INPUT);\n    }\n\n    pinMode(BUTTON_PIN, INPUT);\n\n    Serial.begin(9600);              //  setup serial\n}\n\nvoid loop() {\n    while(!button_state){\n        Button();\n        if (button_state)\n        {\n            Serial.println(\"Started\");\n            delay(200);\n            break;\n        }\n    }\n    while(button_state){\n        Button();\n        if (!button_state)\n        {\n            Serial.println(\"Stopped\");\n            left_servo.write(STOP);\n            right_servo.write(STOP);\n            delay(200);\n            break;\n        }\n        MotorControl();\n        Serial.print(\"Left motor:\");\n        Serial.println(motor_signal[LEFT_MOTOR]);\n        Serial.print(\"Right motor:\");\n        Serial.println(motor_signal[RIGHT_MOTOR]);\n        delay(100); \n    } \n}\n",
			"file": "/C/Users/Christian/Desktop/Service Robotics/service-robotics/Arduino/sketch_nov07a/sketch_nov07a.ino",
			"file_size": 10758,
			"file_write_time": 131545492981145360,
			"settings":
			{
				"buffer_size": 10759,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/C/Users/Christian/Desktop/Service Robotics/service-robotics/Arduino/sketch_nov07a/SpeakerSensors.txt",
			"settings":
			{
				"buffer_size": 661,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "Packages/Python/Python.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "Package Control: ",
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			],
			[
				"Package Control: in",
				"Package Control: Install Package"
			],
			[
				"Pa",
				"Package Control: Install Package"
			]
		],
		"width": 444.0
	},
	"console":
	{
		"height": 130.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Python Solver",
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Python Solver/Pictures"
	],
	"file_history":
	[
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Arduino/sketch_nov07a/sketch_nov07a.ino.ino",
		"/C/Users/Christian/Downloads/PlayerV2.cs",
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Python Solver/Pictures/walk.png",
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Python Solver/Pictures/map.png",
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Python Solver/solver.py",
		"/C/Users/Christian/Desktop/Service Robotics/service-robotics/Python Solver/solver.sublime-project",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/skybox.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/skybox.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/fallbackSize.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/fallbackSize.frag",
		"/C/Users/Christian/Google Drive/Lund/Clases/MMKF15 Applied Robotics/Lab/Assignment_Christian_Oliveros/Assignment_Christian_Oliveros.m",
		"/C/Users/Christian/Google Drive/Lund/Clases/MMKF15 Applied Robotics/Lab/Kinematic_Assignment_Christian_Oliveros.m",
		"/C/Users/Christian/Desktop/wifi_start.bat",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/vector.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/constants.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/main.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/trajectoryGeneration.py",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/wave.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/wave.vert",
		"/C/Users/Christian/Downloads/Telegram Desktop/mierdon",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/phong.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/texture_phong.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/T-50.obj",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/AIM120D.blend.obj",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/mig21C.obj",
		"/C/Users/Christian/Downloads/Telegram Desktop/plane (3).cpp",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/T-50.mtl",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/t50_pak-fa/T-50.obj",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/t50_pak-fa/T-50.mtl",
		"/C/Users/Christian/Downloads/Telegram Desktop/plane (2).cpp",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/texture_phon.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/phong.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/default.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/default.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/AIM120D.obj",
		"/C/Users/Christian/Downloads/Telegram Desktop/phong (2).frag",
		"/C/Users/Christian/Downloads/Telegram Desktop/phong (2).vert",
		"/C/Users/Christian/Downloads/Telegram Desktop/phong.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/parametric_shapes.cpp",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/assignment4.cpp",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/EDAF80_Assignment5.vcxproj.filters",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/CMakeLists.txt",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/EDAF80_Assignment5.vcxproj",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/cmake_install.cmake",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/src/EDAF80/basicNode.h",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/fileReader.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/decimalMath.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/instruction.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/__init__.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Motors/constantsMotor.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Motors/moveMotors.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/Test/correct_test.txt",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/Test/bad_test.txt",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/Utilities/Test/correct_test.text",
		"/C/Users/Christian/Google Drive/Maratones/GANNHAT/gannhat2.cpp",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/vector.py",
		"/C/Users/Christian/Desktop/RaspPi/rasppi-printer/rasp-proy.sublime-project",
		"/C/Users/Christian/Google Drive/Libros/Procesando/vector.py",
		"/C/Users/Christian/Google Drive/Libros/Procesando/rasp-proy.sublime-project",
		"/C/Users/Christian/Downloads/CollisionAvoidance.cs",
		"/C/Users/Christian/Downloads/ObstacleAvoidance.cs",
		"/C/Users/Christian/Downloads/CentralWithShortWhiskers.cs",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/blinnPhong.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/blinnPhong.frag",
		"/C/Users/Christian/Downloads/Telegram Desktop/assignment3 (2).cpp",
		"/C/Users/Christian/Downloads/Telegram Desktop/assignment3.cpp",
		"/C/Users/Christian/Downloads/Telegram Desktop/phong.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/tangent.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/tangent.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/skybox.vet.vs",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/texcoord.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/texcoord.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/diffuse.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/diffuse.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/fullscreen.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/fullscreen.vert",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/fallback.frag",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/shaders/EDAF80/fallback.vert",
		"/C/Users/Christian/SkyDrive/Documents/Juego/CI6450 Mondongo Inc/Assets/Scripts/Camara/cameraMovement.cs",
		"/C/Users/Christian/Documents/cocos2d-x-3.15.1/setup.py",
		"/C/Users/Christian/Documents/Lund/Project/Build/log.txt",
		"/C/Users/Christian/Documents/cocos2d-x-3.15.1/download-deps.py",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/res/scenes/sphere.obj",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/CMakeLists.txt",
		"/C/Users/Christian/Documents/Lund/Project/CG_Labs/0001-fix-compiling-problems-under-vs2017-3.patch",
		"/C/Users/Christian/Documents/Lund/Project/Build/CMakeCache.txt",
		"/C/Users/Christian/Google Drive/Lund/Clases/EDAF80 Computer Graphics/Project/Build/messages.txt",
		"/C/Users/Christian/Google Drive/Lund/Clases/EDAF80 Computer Graphics/Project/Build/errors.txt",
		"/C/Users/Christian/Google Drive/Lund/Clases/EDAF80 Computer Graphics/Project/Build/error.txt",
		"/C/Users/Christian/Google Drive/Lund/Clases/EDAF80 Computer Graphics/Project/Build/cmake_install.cmake",
		"/C/Users/Christian/Google Drive/Maratones/DISTANCE/DISTANCE.cpp",
		"/C/Users/Christian/Google Drive/Lund/Clases/EDAF80 Computer Graphics/Project/CG_Labs/CMakeLists.txt",
		"/C/Users/Christian/SkyDrive/Documents/Juego/Juego ANAR/Library/UnityAssemblies/UnityEngine.dll",
		"/C/Users/Christian/Google Drive/CEIC/Tecnología/ceicsv.sql",
		"/C/Users/Christian/Google Drive/CEIC/Tecnología/base.sql",
		"/D/config.bin",
		"/C/Users/Christian/Google Drive/USB/Bases de Datos/Base de Datos/Lab/Proyecto Fase 2/creaBGV.sql",
		"/C/Users/Christian/SkyDrive/Documents/Juego/Juego-Jugado/README.md",
		"/C/Users/Christian/SkyDrive/Documents/Juego/Juego-Jugado/.gitignore"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"second_black_corner",
			"corner",
			"onLine",
			"readLineSensor",
			"readLineSensors",
			"left_servo",
			"TBN",
			"mtl",
			"\\",
			"mtl",
			"pilot",
			"m.",
			"c.",
			"vec.",
			"ins.",
			"ins",
			"v.",
			"reader",
			"generatePathTrajectory",
			"ins",
			"prog",
			"pattern"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"second_white_corner",
			"top_corner",
			"OnLine",
			"ReadLineSensor",
			"ReadLineSensors",
			"TNB",
			"/",
			"",
			"generateCartesianPathTrajectory",
			"_prog",
			"_pattern"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": true,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "solver.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5161,
						"regions":
						{
						},
						"selection":
						[
							[
								5079,
								5079
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/C/Users/Christian/Desktop/Service Robotics/service-robotics/Arduino/sketch_nov07a/sketch_nov07a.ino",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10759,
						"regions":
						{
						},
						"selection":
						[
							[
								6924,
								6924
							]
						],
						"settings":
						{
							"syntax": "Packages/Arduino-like IDE/Arduino.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4366.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/C/Users/Christian/Desktop/Service Robotics/service-robotics/Arduino/sketch_nov07a/SpeakerSensors.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 661,
						"regions":
						{
						},
						"selection":
						[
							[
								534,
								502
							]
						],
						"settings":
						{
							"syntax": "Packages/Arduino-like IDE/Arduino.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 35.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 155.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.stino_build_panel":
	{
		"height": 0.0
	},
	"output.stino_panel":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "solver.sublime-project",
	"replace":
	{
		"height": 72.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
